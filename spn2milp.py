import timeimport sysimport loggingimport copyfrom statistics import meanfrom pyddlib.mlexpr import MLExprfrom pyddlib.padd import PADD#from gurobipy import *from tqdm import tqdmimport argparseparser = argparse.ArgumentParser()parser.add_argument("--spn_file")parser.add_argument("--order", default="gustavo")args = parser.parse_args()LEAF_STRING = "l"SPN_FILE2 = args.spn_fileORDER = args.orderLOG_FILE = SPN_FILE2[:-5]+'log'LP_FILE = SPN_FILE2[:-5]+'lp'print(SPN_FILE2)print(LP_FILE)print('Writing '+LP_FILE)spn_file = open(SPN_FILE2, "r")logging.basicConfig(format='%(asctime)s %(message)s',\                    datefmt='%m/%d/%Y %I:%M:%S %p',\                    filename=LOG_FILE,\                    filemode='w',\                    level=logging.DEBUG)#MAXN =  120000MAXN = 600000 # for large modelsspn = [None] * MAXNX = [None]A = [None]Y = [None]Ah = [None]d = [None]U = []stack = []G = {}maxv = 0maxs = 0u_count = 0sum_nodes_found = 0latent_variables = 0def dfs(index):    global latent_variables    # logging.debug("New DFS call for index " + str(index))    # logging.debug("SPN node " + str(spn[index]))    # logging.debug("Stack: " + str(stack))    if spn[index][0] == LEAF_STRING:        v = spn[index][1][0]        # logging.debug("Reached a leaf X" + str(v))        if not (isinstance(X[v], PADD)):            X[v] = PADD.variable(maxs + v + 1)            d[v] = X[v] * PADD.constant(MLExpr({("x"+str(v+1)+"_1",): 1})) + \                    ~X[v] * PADD.constant(MLExpr({("x" + str(v+1)+"_0",): 1}))            A[v] = PADD.constant(0.0)        aux = PADD.constant(1.0)        for i in range(len(stack)):            if stack[i][2] == 0:                aux = aux * ~Y[stack[i][1]]            else:                aux = aux * Y[stack[i][1]]        a = PADD.constant(spn[index][1][1])        b = PADD.constant(spn[index][1][2])        aux = aux * (~X[v] * a + X[v] * b)        A[v] = A[v] + aux    if spn[index][0] == "+":        if not (isinstance(Y[index], PADD)):            # logging.debug("Reached a SUM node, creating SPN Ah" + str(index))            Y[index] = PADD.variable(index)            a = PADD.constant(spn[index][1][1])            b = PADD.constant(spn[index][1][3])            Ah[index] = ~Y[index] * a + Y[index] * b            latent_variables += 1        stack.append(("+", index, 0))        dfs(spn[index][1][0])        stack.pop()        stack.append(("+", index, 1))        dfs(spn[index][1][2])        stack.pop()    if spn[index][0] == "*":        for i in range(len(spn[index][1])):            dfs(spn[index][1][i])def evaluate_spn(index, vlist):    if spn[index][0] == LEAF_STRING:        v = spn[index][1][0]        if (vlist[v] == 0):            return spn[index][1][1]        else:            return spn[index][1][2]    if spn[index][0] == "+":        a = spn[index][1][1]        b = spn[index][1][3]        c = evaluate_spn(spn[index][1][0], vlist)        d = evaluate_spn(spn[index][1][2], vlist)        return a*c + b*d    if spn[index][0] == "*":        aux = 1        for i in range(len(spn[index][1])):            aux *= evaluate_spn(spn[index][1][i], vlist)        return auxdef update_u_vars(padd, l=[], u=[]):    global u_count    if (padd.is_terminal()):        aux = PADD.constant(1.0)        if (padd.value.expr in l):            index = u[l.index(padd.value.expr)]        else:            index = u_count            l.append(padd.value.expr)            u.append(u_count)            u_count += 1        for i in range(len(stack)):            if (stack[i][0] > maxs):                var = X[stack[i][0] - maxs - 1]            else:                var = Y[stack[i][0]]            if stack[i][1] == False:                aux = aux * ~var            else:                aux = aux * var        aux = aux * PADD.constant(MLExpr({("u"+str(index),): 1}))        return aux    i = padd.index    stack.append((i, False))    a = update_u_vars(padd.restrict({i: False}), l, u)    stack.pop()    stack.append((i, True))    b = update_u_vars(padd.restrict({i: True}), l, u)    stack.pop()    return a + bdef check_connectivity(G, v):    if (len(G) < 2):        return True    H = {}    valid = -1    for i in G:        if ({i} != v):            aux = G[i] - v            H[i] = aux            valid = i    vlist = set(H) - {valid}    queue = [valid]    while (len(queue) > 0):        i = queue.pop(0)        for j in H[i]:            if (j in vlist):                vlist = vlist - {j}                queue.append(j)    if (len(vlist) == 0):        return H    return False# It seems to work as the older onedef newPADD_to_list(P):    r = []    for node in P:        if (node.is_terminal()):            if not (node in r):                r.append(node)    return rdef PADD_to_list(P):    ilist = P.set_of_index()    ilist = sorted(list(ilist))    r = []    __PADD_to_list_step(P, ilist, 0, r)    return r   def __PADD_to_list_step(P, ilist, i, r):    if (i < len(ilist)):        __PADD_to_list_step(P.restrict({ilist[i]: False}), ilist, i+1, r)        __PADD_to_list_step(P.restrict({ilist[i]: True}), ilist, i+1, r)        return    r.append(P)start_time = time.time()logging.debug("# Parsing %s" % SPN_FILE2)for line in spn_file:    line = line.split(" ")    t = line[0]    if (t == LEAF_STRING) or (t == "*"):        if (t == LEAF_STRING) and (int(line[2]) > maxv):            maxv = int(line[2])        spn[int(line[1])] = (t, [int(i) for i in line[2:]])    if t == "+":        (h, l) = (int(line[2]), int(line[4]))        (wh, wl) = (float(line[3]), float(line[5]))        # If this a sum node with indicator nodes as children        if (spn[h][0] == spn[l][0] == LEAF_STRING) and (spn[h][1][0] == spn[l][1][0]):            spn[int(line[1])] = (LEAF_STRING, [spn[h][1][0], wh, wl])        else:            if int(line[1]) > maxs:                maxs = int(line[1])            spn[int(line[1])] = (t, [h, wh, l, wl])            sum_nodes_found += 1spn_file.close()logging.debug("# File parsed")logging.debug("# Variables = %d" %(maxv+1))#print("# Variables = %d" %(maxv+1))logging.debug("# Sum nodes = %d" %sum_nodes_found)# logging.debug(spn)X = X * (maxv + 1)A = A * (maxv + 1)Y = Y * (maxs + 1)Ah = Ah * (maxs + 1)d = d * (maxv + 1)logging.debug("# Building ADDs and PADDs by DFS")dfs(0)assert sum_nodes_found == latent_variableslogging.debug("# ADDs and PADDs built")logging.debug("# X variables created = %d" %(maxv + 1))logging.debug("# Y (latent) variables created = %d" % latent_variables)# # ---------------------------------------------------- TESTE TESTE TESTE!# # aux = PADD.constant(1.0)# # print("Multiplying A and d")# # for i in range(len(A)):# #     if (isinstance(A[i], PADD)):# #         print(i)# #         aux *= A[i]# #     if (isinstance(d[i], PADD)):# #         print(i)# #         aux *= d[i]# # print("Multiplying Ah")# # for i in reversed(range(len(Ah))):# #     if (isinstance(Ah[i], PADD)):# #         print(i)# #         aux *= Ah[i]# # #aux.pdfgraph("testedenis")# # # print("Marginalizing Y")# # # for i in range(len(Y)):# # #     if (isinstance(Y[i], PADD)):# # #         print(i)# # #         aux = aux.marginalize(Y[i])# # # print("Marginalizing X")# # # for i in range(len(X)):# # #     if (isinstance(X[i], PADD)):# # #         print(i)# # #         aux = aux.marginalize(X[i])# # print("Terms in aux")# # aux = PADD_to_list(aux)# # for node in aux:# #     s = node.value.precision_str()# #     print(s)# # # import itertools # # # soma = 0# # # for i in itertools.product([0,1],repeat=6):# # #     soma += evaluate_spn(0, i)# # # print(soma)# # exit()logging.debug("# Building Domain Graph")# building Domain Graph for variables X and Y#print(A)for a in A:    set_aux = a.set_of_index()    for i in set_aux:        if i in G:            G[i].update(set_aux)        else:            G[i] = set(set_aux)        G[i] = G[i] - {i}logging.debug("# Domain Graph built")x_stats = []x_max = 0x_min = 9999x_path = []y_stats = []y_max = 0y_min = 9999y_path = []for v in G:    if v > maxs:        x_stats.append(len(G[v]))        x_path.append((len(G[v]), v))        x_max = max(x_max, len(G[v]))        x_min = min(x_min, len(G[v]))    else:        i = 0        for u in G[v]:            if u > maxs:                i += 1        y_stats.append(i)        y_path.append((i, v))        y_max = max(y_max, i)        y_min = min(y_min, i)logging.debug("# X dependency on Y")logging.debug("# Average: %3.2f" %mean(x_stats))logging.debug("# Max: " + str(x_max) + "\tMin: " + str(x_min))logging.debug("# Y appearances in X")logging.debug("# Average: " + str(mean(y_stats)))logging.debug("# Max: " + str(y_max) + "\tMin: " + str(y_min))# logging.debug(G)logging.debug("# Building Variable Elimination Order")veolist = []setY = set()x_path = sorted(x_path)for x in x_path:	veolist.append({x[1]})	setY.update(G[x[1]])l = sorted(setY)#.reverse()l = list(reversed(l))if ORDER == 'gustavo':	i = 0	auxs = set()	for y in l:		auxs.add(y)		i += 1		if (i > sum_nodes_found / 200):			veolist.append(auxs)			auxs = set()			i = 0	if (auxs):		print("rapa do tacho")		veolist.append(auxs)else:   # Denis' order	for y in l:	       veolist.append({y})logging.debug("# Variable Elimination Order Built")logging.debug("# Building Messages")# Passing messages and building constraints A_check = [True] * (maxv + 1)d_check = [True] * (maxv + 1)Ah_check = [True] * (maxs + 1)message = []previous_u = PADD.constant(1.0)u_diff = 0u_count = maxv + 2veolist.append(set())for i in tqdm(range(len(veolist) - 1)):	#print(i,len(veolist))    # print("veolist[" + str(i) + "]: " + str(veolist[i]))    # logging.debug("---------")    # logging.debug("New Step of Message Passing:")    # logging.debug("i = " + str(i) + " : " + str(veolist[i]))    # logging.debug("Variables that will leave Path Decomposition")    vars_to_leave = veolist[i] - veolist[i + 1]    vars_to_leave = list(reversed(sorted(vars_to_leave)))    #print(vars_to_leave)        # logging.debug(vars_to_leave)    if (vars_to_leave):        aux = PADD.constant(1.0)        # logging.debug("Finding PADDs with the leaving variables")        # Building PADD from functions related to actual node of veolist        for index in vars_to_leave:            # print("Var to leave: ", index)            # If it is a variable Xi (original SPN variable)            if (index > maxs):                x_index = index - maxs - 1                #print("X" + str(x_index))                if (d_check[x_index]):                    #print("d(X" + str(x_index) + ") belongs here")                    aux *= d[x_index]                    d_check[x_index] = False                if (A_check[x_index]):                    #print("A(X" + str(x_index) + ") belongs here")                    aux *= A[x_index]                    A_check[x_index] = False            # Otherwise, it is a variable Yi (added because a sum node)            else:                #print("Y" + str(index))                related_vars = G[index]                for v in related_vars:                    # If v is a X variable                    if (v > maxs):                        x_index = v - maxs - 1                        if (A_check[x_index]):                            #print("A[" + str(x_index) + "]")                            #print(A[x_index].set_of_index())                            aux *= A[x_index]                            A_check[x_index] = False                if (Ah_check[index]):                    #print("Ah(Y" + str(index) + ") belongs here")                    aux *= Ah[index]                    Ah_check[index] = False        # logging.debug("Previous Message")        # logging.debug(previous_u)        # logging.debug("Message built for this node")        # logging.debug(aux)        # logging.debug("Multiplying previous and actual messages")        #print("s1 |aux|:", len(aux.set_of_index())) #, aux.set_of_index())        # aux.pdfgraph("teste" + str(i))        aux = aux * previous_u        # if (index <= maxs):        #     print(aux)        # aux.pdfgraph("teste" + str(i) + "u")        # logging.debug(aux)        # print("----")        # print("Marginalizing")        #print("s2 |aux*u|:", len(aux.set_of_index())) #, aux.set_of_index())        l = vars_to_leave        ## print(l)        for index in l:            #print("Marginalizing:")            if (index > maxs):                x_index = index - maxs - 1                #print("X" + str(x_index))                # aux = aux.marginalize(X[x_index])                aux = aux.restrict({index: False}) + aux.restrict({index: True})            else:                #print("Y" + str(index))                # aux = aux.marginalize(Y[index]) # TESTE POS CONVERSA DENIS                aux = aux.restrict({index: False}) + aux.restrict({index: True})        # if (index <= maxs):        #     print(aux)        # aux.pdfgraph("teste" + str(i) + "_m")        #print("s3", len(aux.set_of_index()))        # s = aux.value.precision_str()        # print(s)        message.append(aux)        u_diff = u_count        u = update_u_vars(aux)        #print("s4", len(u.set_of_index()), u_diff)        # logging.debug("New variables for each expression in actual message")        # logging.debug(u)        U.append(u)        u_diff = u_count - u_diff        #print("s5", u_count, "|new variables|:", u_diff)        previous_u = u    if (len(veolist[i + 1]) == 0):        # print("i: ", i, veolist[i + 1])        veolist.pop()        # for i in range(len(message)):            # print(U[i])            # print(message[i])        U.pop()        u_count -= u_diff        U.append(PADD.constant(MLExpr({("u"+str(u_count),):1})))        u_count += 1# Checking if all PADDs were addedfor i in range(len(A)):    if (isinstance(A[i], PADD)):        if (A_check[i] == True):            print("CAGOU A_check")        if (d_check[i] == True):            print("CAGOU d_check")for i in range(len(Ah)):    if (isinstance(Ah[i], PADD)):        if (Ah_check[i] == True):            print("CAGOU Ah_check")for i in message[-1].set_of_index():    print("end", i)    if (i > maxs):        var = X[i - maxs - 1]    else:        var = Y[i]    message[-1] = message[-1].marginalize(var)logging.debug("# Messages built")logging.debug("# %d message variables were added" % (u_count-maxv-2))logging.debug("# Adjusting MILP Replacement Variables")milp_vars = {}for m in message:    for node in m:        if (node.is_terminal()):            for term in node.value.expr:                if ((len(term) > 1) and (term not in milp_vars)):                    n = 0                    x_vars = []                    for i in term:                        # If i in term is a variable X                        i = int(i.split("_")[0][1:])                        if (i <= (maxv + 1)):                            n += 1                            x_vars.append(i)                    l = [n, tuple(x_vars)]                    # If there is a u variable (message)                    if (n < len(term)):                        if (n > 1):                            l.append(u_count)                            u_count += 1                        l.append(term[-1])                    l.append(u_count)                    u_count += 1                    milp_vars[term] = l# type(term) >> <class 'tuple'># milp_vars[term] = # [#  n            :   number of X variables in the term#  (Xi, ..., Xk):   tuple with all X variables in term#  newID_(z)    :IF nedded, when n > 1 and u exists#  ID_(u)       :IF exists, message variable#  newID_(g)    :   new G variable ID for adjusting x_i * u_(id)#                   or x_i * ... * x_j # ]# We might note that G can be the adjustment for Xi * u_(id)logging.debug("# Mapped terms with product of variables")logging.debug("%d MILP adjustment variables were added" % len(milp_vars))# for i in milp_vars:#     print(i, milp_vars[i])logging.debug("# Writing %s output file" % LP_FILE)milp_file = open(LP_FILE, "w")# dfile = open(filename + "_debug.log", "w")milp_file.write("Maximize\n")objf = U[-1].value.__repr__()milp_file.write("  " + objf + "\n")add_to_binary = set()add_to_bounds = set()written_constraints = set()milp_file.write("Subject To\n")for i in range(len(message)):    right = newPADD_to_list(U[i])    left = newPADD_to_list(message[i])    assert (len(left) == len(right))    for j in range(len(right)):        rightstr = right[j].value.__repr__()        expr = left[j].value.expr        # dfile.write(rightstr + " = " + str(left[j].value) + "\n")        repl_expr = {}        for term in expr:            # If term has more than 1 variable            if (len(term) > 1):                data = milp_vars[term]                repl_var = (data[-1],)                repl_expr[repl_var] = expr[term]                # n := number of X variables in term                            n = data[0]                x_vars = data[1]                # IF the term is in the form "xi * uj"                z = None                if n > 1:                    c = "  "                    z = "x" + str(data[2])                    for x in x_vars:                        if x > 0:                            sx = "x" + str(x)                        else:                            sx = "y" + str(-x)                            #sx = "x̄" + str(-x)                        str1 = "  " + z + " - " + sx + " <= 0\n"                        if not (str1 in written_constraints):                            milp_file.write(str1)                            written_constraints.add(str1)                        c += sx + " + "                    c = c[:-2] + "- " + z + " <= "+ str(n-1) +"\n"                    if not (c in written_constraints):                        milp_file.write(c)                        written_constraints.add(c)                    add_to_binary.add(z)                if n < len(term):                    if z is None:                        if x_vars[0] > 0:                            z = str(x_vars[0])                        else:                            z = str(x_vars[0])                            #z = "x̄" + str(-x_vars[0])                    #assert term[0] == x_vars[0]                    #assert max(term) == data[-2]                    u = str(data[-2])                    g = str(data[-1])                    str1 = "  " + g + " - " + u + " <= 0\n"                    str2 = "  " + g + " - " + z + " <= 0\n"                    if not (str1 in written_constraints):                        milp_file.write(str1)                        written_constraints.add(str1)                    if not (str2 in written_constraints):                        milp_file.write(str2)                        written_constraints.add(str2)                    s = "  " + z + " + " + u + " - " + g + " <= 1\n"                    if not (s in written_constraints):                        milp_file.write(s)                        written_constraints.add(s)                    add_to_bounds.add(g)            else:                repl_expr[term] = expr[term]        repl_expr = MLExpr(repl_expr)        if (len(repl_expr.expr) == 1) and (() in repl_expr.expr):            str1 = "  " + rightstr + " = " + str(repl_expr.expr[()]) + "\n"        else:            leftstr = repl_expr.precision_str()            str1 = "  " + leftstr + " - " + rightstr + " = 0\n"        if not (str1 in written_constraints):            milp_file.write(str1)            written_constraints.add(str1)for i in range(maxv + 1):    n = str(i + 1)    milp_file.write("  y" + n + " + x" + n + " = 1\n")    #milp_file.write("  x̄" + n + " + x" + n + " = 1\n")milp_file.write("Bounds\n")for u in U:    for var in u:        if var.is_terminal():            milp_file.write("  0 <= " + var.value.__repr__() + " <= 1\n")# Writing g variables bounds, where g = Xi * Ujfor g in add_to_bounds:    milp_file.write("  0 <= " + g + "\n")milp_file.write("Binary\n ")for i in range(maxv + 1):    n = str(i + 1)    milp_file.write(" y" + n + " x" + n)    #milp_file.write(" x̄" + n + " x" + n)for i in add_to_binary:    milp_file.write(" " + i)milp_file.write("\n")milp_file.write("End")milp_file.close()# dfile.close()logging.debug("# .lp output file written")elapsed_time = time.time() - start_timelogging.debug("# Elapsed time: " + str(elapsed_time))# logging.debug("")# logging.debug("---------- Calling solver (Gurobi) for MAP Inference")# # Calling Gurobi# try:#     m = read(filename)#     m.Params.MIPFocus = 1#     m.Params.IntFeasTol = 1e-8#     m.optimize()#     gurobi_vars = []#     for v in m.getVars():#         if (v.varName[1] != "̄"):#             gurobi_vars.append((int(v.varName[1:]), v.x))#         # else:#         #     gurobi_vars.append((int(v.varName[2:]), v.x))#     xsum = 0#     check_result = []#     for v in sorted(gurobi_vars):#         if (v[0] < maxv + 2):#             logging.debug("x" + str(v[0]) + ": " + str(int(v[1])))#             if (v[1] > 0.5):#                 xsum += 1#                 check_result.append(1)#             else:#                 check_result.append(0)##     logging.debug("Xsum =   " + str(xsum))#     logging.debug("Runtime  " + str(float(m.Runtime)))#     logging.debug("ObjVal   " + str(float(m.objVal)))##     logging.debug("---------- Using evidence to check SPN evaluation")#     #dvalue = evaluate_spn(0, check_result)#     logging.debug("ObjVal   " + str(float(m.objVal)))#     #logging.debug("SPN Eval " + str(float(dvalue)))#     logging.debug("")#     logging.debug("---------- Valid Answer?")#     #if (abs(m.objVal - dvalue) < 1e-6):#     #    logging.debug("YES!")#     #else:#     #    logging.debug("NO... =(")# except GurobiError:#     print('Error reported')#print(maxv)